
<html>
	<head>
		<link href="https://fonts.googleapis.com/css?family=Abril+Fatface|Share+Tech+Mono|Bungee+Shade|Cinzel:400,700|Cute+Font|Faster+One|Monoton|Permanent+Marker|Quicksand:400,600,700|Special+Elite|Vibes&display=swap" rel="stylesheet">
		<link href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" rel="stylesheet">
		<link href="./style.css" rel="stylesheet">
		<script src="./app.js"></script>
	</head>
	<body style="display:none;">
		<div id="front-center">
			<input type="text" name="" id="filter" autofocus autocomplete="off">
			<div class="footer">
				<span class="c">© 2019 x1n13y84issmd42</span>
				<span class="pipe"></span>
				<a href="https://github.com/x1n13y84issmd42/70015">GitHub</a>
				<span class="pipe"></span>
				<span class="c">With elitism in ♥</span>
			</div>
		</div>

		<div id="tools"></div>

		<script>
			let config = new LSConfig();
			let bench = new Workbench(config);
		</script>



<div id="components">

	<dialog data-purpose="social" id="share" title="${title}">
		<section id="link">
			<input type="text" label="<<${title} a link>>" value="${value}" />
			<undercontrols>
				<copy from="link"></copy>
			</undercontrols>
		</section>
	</dialog>

	<div class="kvpair kvsection">
		<span class="label">${label}</span>
	</div>

	<div class="kvpair kv">
		<span class="label">${k}</span>
		<span class="value copy">${v}</span>
	</div>

	<h1 class="sectionLabel">${label}</h1>

</div>

<div id="toolshed">
	<!-- it continues in epilogue.html -->


<tool _id="base64" data-tag="base64" name="Base64">
	<section _id="base64">
		<input type="area" rows="8" label="Base64-encoded string">
		<undercontrols>
			<reuse>
				<hasher input="#base64">Hash it</hasher>
			</reuse>
			<copy from="#base64"></copy>
		</undercontrols>
	</section>

	<div class="bothways">It works ⇃both↾ ways.</div>

	<section _id="ascii">
		<input type="area" rows="8" label="ASCII string">
		<undercontrols>
			<reuse>
				<hasher input="#ascii">Hash it</hasher>
			</reuse>
			<copy from="#ascii"></copy>
		</undercontrols>
	</section>
</tool>

<script>
	(() => {
		class TBase64 extends Tool {
			constructor(id) {
				super(id);

				this.inBase64 = this.Section('base64').Input();
				this.inAscii = this.Section('ascii').Input();

				this.inBase64.oninput = () => this.decode();
				this.inAscii.oninput = () => this.encode();
			}

			decode() {
				this.inAscii.value = atob(this.inBase64.value);
			};
			
			encode() {
				this.inBase64.value = btoa(this.inAscii.value);
			};

			import(data) {
				if (data.ascii) {
					this.inAscii.value = data.ascii;
					this.encode();
				}
				
				if (data.base64) {
					this.base64.value = data.base64;
					this.decode();
				}
			}
		}

		let comp = Component.New('base64');
		window.tools.appendChild(comp);
		bench.add(new TBase64(comp));
	})()
</script>



<tool _id="hasher" data-tag="hash md5 sha des" name="Hashes &amp; ciphers">
	<input type="text" _id="input" autofocus tabindex="21" label="Input"/>
	<input type="text" class="hasherKeyInput" _id="key" autofocus tabindex="21" label="Encryption key" />

	<div class="results subsection"></div>
</tool>

<script src="./node_modules/crypto-js/crypto-js.js?dontcachemepls"></script>
<script src="./node_modules/js-crc/build/crc.min.js?dontcachemepls"></script>

<script>
	(() => {
		class THasher extends Tool {
			constructor(id) {
				super(id);

				this.input = this.$$('input');
				this.keyInput = this.$$('key');

				this.keyInput.oninput = this.input.oninput = () => this.hash();
			}

			hash() {
				let results = this.$(".results")[0];
				this.removeChildren(results);

				results.appendChild(this.Component('kvsection', {label: "Checksums"}));
				results.appendChild(this.Component('kv', {k: "CRC16", v: crc16(this.input.value)}));
				results.appendChild(this.Component('kv', {k: "CRC32", v: crc32(this.input.value)}));
				
				results.appendChild(this.Component('kvsection', {label: "Hashes"}));
				results.appendChild(this.Component('kv', {k: "MD5", v: '' + CryptoJS.MD5(this.input.value)}));
				results.appendChild(this.Component('kv', {k: "SHA1", v: '' + CryptoJS.SHA1(this.input.value)}));
				results.appendChild(this.Component('kv', {k: "SHA3", v: '' + CryptoJS.SHA3(this.input.value)}));
				results.appendChild(this.Component('kv', {k: "SHA256", v: '' + CryptoJS.SHA256(this.input.value)}));
				
				results.appendChild(this.Component('kvsection', {label: "Ciphers"}));
				let aes = CryptoJS.AES.encrypt(this.input.value, this.keyInput.value, {keySize: 128});
				let des = CryptoJS.DES.encrypt(this.input.value, this.keyInput.value, {keySize: 128});
				// console.log(aes);
				// console.log(aes.key.toString());
				// console.log(aes.iv.toString());
				// console.log(aes.ciphertext.toString());
				// console.log(aes.key);
				// console.log(aes.iv);
				// console.log(aes.ciphertext);
				results.appendChild(this.Component('kv', {k: "AES", v: aes.ciphertext.toString()}));
				results.appendChild(this.Component('kv', {k: "DES", v: des.ciphertext.toString()}));
			};

			import(data) {
				if (data.input) {
					this.T(this.$$('input'), data.input);
					this.hash();
				}
			}
		}

		let comp = Component.New('hasher');
		window.tools.appendChild(comp);
		bench.add(new THasher(comp));
	})()
</script>



<tool _id="unixtime" data-tag="unixtime" name="Unixtime">
	<section _id="ts">
		<input type="text" autofocus label="Unixtime">
		<undercontrols error="true"></undercontrols>
	</section>

	<section _id="formatted">
		<div class="left l35">
			<div class="typographyDate copy">
				<p class="l10">&nbsp;</p>
			</div>
		</div>
		
		<div class="right r65">
			<div class="dates"></div>
		</div>
	</section>
</tool>

<script>
	(()=>{
		class TUnixtime extends Tool {
			constructor(id) {
				super(id);
	
				this.inTS = this.Section('ts').Input();
				this.dates = this.$('.dates')[0];
	
				this.inTS.oninput = () => this.convert();
			}
	
			convert() {
				this.removeChildren(this.dates);
	
				try {
					let d = new Date();
					d.setTime(this.inTS.value.trim() + "000")
	
					this.typographyDate(d);
					this.dates.appendChild(this.Component("kvsection", {label: "Formatted"}))
					this.dates.appendChild(this.Component("kv", {k: "ISO 8601", v: d.toISOString()}))
					this.dates.appendChild(this.Component("kv", {k: "Date.toString()", v: d.toString()}))
					this.Section('ts').Error(undefined);
					this.Section('formatted').Show();
				} catch (err) {
					this.Section('ts').Error(err.message);
					this.Section('formatted').Hide();
				}
			}
	
			typographyDate(d) {
				let timezone = undefined;
				let eTZT = document.createElement("p");
				let opts = {
					timezone,
					weekday: "long",
					month: "long",
					year: "numeric",
					day: "numeric",
					hour: "numeric",
					minute: "numeric",
					second: "numeric",
				};
	
				let locale = "en-US";
				let weekday = d.toLocaleDateString(locale, {timezone, weekday: "long"});
				let weekdayClass = "l" + weekday.length;
				let weekdayE = document.createElement("p");
				let month = d.toLocaleDateString(locale, {timezone, month: "long", day: "numeric"});
				let monthClass = "l" + month.length;
				let monthE = document.createElement("p");
				let year = d.toLocaleDateString(locale, {timezone, year: "numeric"});
				let yearClass = "l" + year.length;
				let yearE = document.createElement("p");
				let time = d.toLocaleDateString(locale, {timezone, hour: "numeric", minute: "numeric", second: "numeric"}).split(', ')[1] || "00";
				let timeClass = "l" + time.length;
				let timeE = document.createElement("p");
	
				weekdayE.classList.add("weekday", weekdayClass);
				weekdayE.innerHTML = weekday;
				monthE.classList.add("month", monthClass);
				monthE.innerHTML = month;
				yearE.classList.add("year", yearClass);
				yearE.innerHTML = year;
				timeE.classList.add("time", timeClass);
				timeE.innerHTML = time;
	
				let tdE = this.$(".typographyDate")[0];
				this.removeChildren(tdE)
	
				tdE.dataset.value = `${weekday}, ${month} ${year}, ${time}`;
	
				tdE.appendChild(weekdayE);
				tdE.appendChild(monthE);
				tdE.appendChild(yearE);
				tdE.appendChild(timeE);
			}
		}
	
		let comp = Component.New('unixtime');
		window.tools.appendChild(comp);
		bench.add(new TUnixtime(comp));
	})()
</script>

<style>
	#unixtime .dates .kvpair > .label {
		padding-bottom: 2em;
	}

	.timezones > p {
		opacity: 0;
		font-family: Quicksand;
	}

	.timezones > p.v {
		opacity: 1;
		font-family: Quicksand;
		transition: all 400ms ease-in-out;
		-webkit-transition: all 400ms ease-in-out;
		-moz-transition: all 400ms ease-in-out;
		-o-transition: all 400ms ease-in-out;
	}
								
	.timezones > p > i {
		margin-right: 20px;
		font-family: inherit;
		display: inline-block;
		width: 110px;
		font-style: normal;
	}

	.timezones > p > span {
		font-family: inherit;
		font-size: 125%;
	}

	#unixtime .typographyDate {
		font-family: Share Tech Mono;
		width: 370px;
	}
	
	#unixtime .typographyDate:hover {
		transform: scale(1.05);
		color: #00BBFF;
		transition: all 100ms ease-in-out;
	}

	#unixtime .typographyDate > * {
		font-family: inherit;
		line-height: 90%;
		cursor: pointer;
	}

	#unixtime .typographyDate > .l1 {font-size: 500.00pt;}
	#unixtime .typographyDate > .l2 {font-size: 250.00pt;}
	#unixtime .typographyDate > .l3 {font-size: 166.67pt;}
	#unixtime .typographyDate > .l4 {font-size: 125.00pt;}
	#unixtime .typographyDate > .l5 {font-size: 100.00pt;}
	#unixtime .typographyDate > .l6 {font-size: 83.33pt;}
	#unixtime .typographyDate > .l7 {font-size: 71.43pt;}
	#unixtime .typographyDate > .l8 {font-size: 62.50pt;}
	#unixtime .typographyDate > .l9 {font-size: 55.56pt;}
	#unixtime .typographyDate > .l10 {font-size: 50.00pt;}
	#unixtime .typographyDate > .l11 {font-size: 45.45pt;}
	#unixtime .typographyDate > .l12 {font-size: 41.67pt;}
	#unixtime .typographyDate > .l13 {font-size: 38.46pt;}
	#unixtime .typographyDate > .l14 {font-size: 35.71pt;}
	#unixtime .typographyDate > .l15 {font-size: 33.33pt;}
	#unixtime .typographyDate > .l16 {font-size: 31.25pt;}
	#unixtime .typographyDate > .l17 {font-size: 29.41pt;}
	#unixtime .typographyDate > .l18 {font-size: 27.78pt;}
	#unixtime .typographyDate > .l19 {font-size: 26.32pt;}
	#unixtime .typographyDate > .l20 {font-size: 25.00pt;}
	#unixtime .typographyDate > .l21 {font-size: 23.81pt;}
	#unixtime .typographyDate > .l22 {font-size: 22.73pt;}
	#unixtime .typographyDate > .l23 {font-size: 21.74pt;}
	#unixtime .typographyDate > .l24 {font-size: 20.83pt;}
	#unixtime .typographyDate > .l25 {font-size: 20.00pt;}
	#unixtime .typographyDate > .l26 {font-size: 19.23pt;}
	#unixtime .typographyDate > .l27 {font-size: 18.52pt;}
	#unixtime .typographyDate > .l28 {font-size: 17.86pt;}
	#unixtime .typographyDate > .l29 {font-size: 17.24pt;}
	#unixtime .typographyDate > .l30 {font-size: 16.67pt;}
	#unixtime .typographyDate > .l31 {font-size: 16.13pt;}
	#unixtime .typographyDate > .l32 {font-size: 15.63pt;}
	#unixtime .typographyDate > .l33 {font-size: 15.15pt;}
	#unixtime .typographyDate > .l34 {font-size: 14.71pt;}
	#unixtime .typographyDate > .l35 {font-size: 14.29pt;}
	#unixtime .typographyDate > .l36 {font-size: 13.89pt;}
	#unixtime .typographyDate > .l37 {font-size: 13.51pt;}
	#unixtime .typographyDate > .l38 {font-size: 13.16pt;}
	#unixtime .typographyDate > .l39 {font-size: 12.82pt;}
	#unixtime .typographyDate > .l40 {font-size: 12.50pt;}
	#unixtime .typographyDate > .l41 {font-size: 12.20pt;}
	#unixtime .typographyDate > .l42 {font-size: 11.90pt;}
	#unixtime .typographyDate > .l43 {font-size: 11.63pt;}
	#unixtime .typographyDate > .l44 {font-size: 11.36pt;}
	#unixtime .typographyDate > .l45 {font-size: 11.11pt;}
	#unixtime .typographyDate > .l46 {font-size: 10.87pt;}
	#unixtime .typographyDate > .l47 {font-size: 10.64pt;}
	#unixtime .typographyDate > .l48 {font-size: 10.42pt;}
	#unixtime .typographyDate > .l49 {font-size: 10.20pt;}
	#unixtime .typographyDate > .l50 {font-size: 10.00pt;}
</style>



<tool _id="urldecode" data-tag="url trans encode decode" name="Transcode URL">
	<section _id="encoded">
		<input type="text" autofocus tabindex="11" label="URL-encoded string">
		<undercontrols>
			<copy from="#encoded"></copy>
		</undercontrols>
	</section>

	<div class="bothways">It works ⇃both↾ ways.</div>

	<section _id="decoded" >
		<label for="urldecode-encinput"></label>		
		<input type="text" label="ASCII string" tabindex="12" onFocus="this.tabIndex=10;" onBlur="this.tabIndex=12;">
		<undercontrols>
			<copy from="#decoded"></copy>
		</undercontrols>
	</section>
</tool>

<script>
	(() => {
		class TURLTranscoder extends Tool {
			constructor(id) {
				super(id)
				
				this.encoded = this.Section('encoded').Input();
				this.decoded = this.Section('decoded').Input();
				this.encoded.oninput = () => this.decode();
				this.decoded.oninput = () => this.encode();
			}
			
			decode() {
				this.decoded.value = decodeURIComponent(this.encoded.value);
			};
			
			encode() {
				this.encoded.value = encodeURIComponent(this.decoded.value);
			};
			
		}
		
		let comp = Component.New('urldecode');
		window.tools.appendChild(comp);
		bench.add(new TURLTranscoder(comp));
	})()
</script>



<tool _id="urlparse" name="Parse URL" data-tag="urlparse">
	<section _id="url">
		<input type="text" label="URL">
		<undercontrols error="true"></undercontrols>
	</section>

	<section _id="fields">
		<div class="fields"></div>
	</section>
</tool>

<script>
	(() => {
		class TURLParser extends Tool {
			constructor(id) {
				super(id);
				this.URL = this.Section("url").Input();

				this.URL.oninput = () => {
					let fields = this.$(".fields")[0];
					this.removeChidren(fields);

					let url;

					try {
						url = new URL(this.URL.value);
						this.Section("url").Error(undefined);
						this.Section('fields').Show();
					} catch (err) {
						this.Section("url").Error(err.message);
						this.Section('fields').Hide();
						return;
					}
					
					fields.appendChild(this.Component("kvsection", {label: "URL"}));
					url.protocol && fields.appendChild(this.Component("kv", {k: "Protocol", v: url.protocol}));
					url.hostname && fields.appendChild(this.Component("kv", {k: "Domain", v: url.hostname}));
					url.username && fields.appendChild(this.Component("kv", {k: "Username", v: url.username}));
					url.password && fields.appendChild(this.Component("kv", {k: "Password", v: url.password}));

					if (url.path) {
						fields.appendChild(this.Component("kv", {k: "Path", v: url.path}));
					} else if (url.pathname) {
						fields.appendChild(this.Component("kv", {k: "Path", v: url.pathname}));
					}

					url.port && fields.appendChild(this.Component("kv", {k: "Port", v: url.port}));
					url.hash && fields.appendChild(this.Component("kv", {k: "Hash", v: url.hash}));

					if (url.search && url.searchParams) {
						fields.appendChild(this.Component("kvsection", {label: "Query"}));
						let sp = this.improveSearchParams(url.searchParams);
						for (let spn in sp) {
							let spv = sp[spn];
							if (spv instanceof Array) {
								let t = true;
								for (let spvv of spv) {
									fields.appendChild(this.Component("kv", {k: t ? (t = false, spn) : "", v: spvv}));
								}
							} else {
								fields.appendChild(this.Component("kv", {k: spn, v: spv}));
							}
						}
					}
				};
			}
			
			/**
			 * Stores array values as arrays.
			 */
			improveSearchParams(urlsp) {
				let res = {};
				for (let e of urlsp.entries()) {
					let qspn = e[0];
					let qspv = e[1];

					if (qspn.substr(-2) == '[]') {
						qspn = qspn.substr(0, qspn.length - 2);
						res[qspn] || (res[qspn] = []);
						res[qspn].push(qspv);
					} else {
						res[qspn] = qspv;
					}
				}

				return res;
			}
		}

		let comp = Component.New('urlparse');
		window.tools.appendChild(comp);
		bench.add(new TURLParser(comp));
	})()
</script>



		<!-- opened in components.html -->
		</div>

		<script>
			function focus(id) {
				bench.focus(id);
			}

			function unfocus(id) {
				bench.unfocus(id);
				window.location.hash = '';
				filter.focus();
			}

			/**
			 * Temporarily applies a class to an element. The class is removed after the specified amount of time passes.
			 * @param {HTMLElement} e An element to style.
			 * @param {string} className A class name to apply temporarily.
			 * @param {number} time A time period the class should be removed after.
			 */
			function tmpStyle(e, className, time) {
				e.classList.add(className);
				setTimeout(() => {
					e.classList.remove(className);
				}, time);
			}

			function copiedFloater(x, y) {
				let fltr = document.createElement('div');
				fltr.classList.add("floater");
				fltr.style.left = (x - 45) + "px";
				fltr.style.top = (y - 35) + "px";
				fltr.innerHTML = 'Copied.';
				document.body.appendChild(fltr);

				setTimeout(() => {
					fltr.classList.add("vanishing");
				}, 0);

				setTimeout(() => {
					document.body.removeChild(fltr);
				}, 1000);
			}

			function onclickCopyToClipboard(e) {
				let from = e.currentTarget;

				//	Looking for a disabled parent.
				let pn = from.parentNode;
				while (pn) {
					if (pn.classList && pn.classList.contains('disabled')) {
						return;
					}
					pn = pn.parentNode;
				}

				if (from.dataset.value) {
					Clipboard.copy(from.dataset.value);
					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
					return;
				}
				
				if (from.dataset.from) {
					from = document.getElementById(from.dataset.from);
				}
				
				if (from) {	
					switch (from.tagName) {
						case "INPUT":
						case "TEXTAREA":
							Clipboard.copy(from.value);
							break;
							
						default:
							Clipboard.copy(from.innerHTML);
							break;
					}

					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
				}
			}

			document.body.onload = () => {
				// let dialogE = Component.New('share', {
				// 	title: 'Share',
				// 	value: `${window.location.pathname}#yolo2020`
				// });
				// document.body.appendChild(dialogE);

				let filter = document.getElementById("filter");
				filter.oninput = () => {
					bench.filter(filter.value);
				}
				
				filter.onkeydown = (e) => {
					if (e.key == 'Enter') {
						//	Focusing the only matched tool.
						let matched = document.querySelectorAll(".matched");
						if (matched.length == 1) {
							focus(matched[0].id);
							e.preventDefault();
							e.cancelBubble = true;
						}
					} else if (e.key == 'Escape') {
						//	Clearing the filtering.
						filter.value = "";
						bench.filter("");
					}
				}

				//	Copy buttons.
				document.querySelectorAll('.copy').forEach((v, k, p) => {v.onclick = onclickCopyToClipboard});

				//	Autofocusing tools upon page load.
				if (window.location.hash) {
					bench.focus(window.location.hash.substr(1));
				}

				bench.render();
			}
		</script>
	</body>
</html>


