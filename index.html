
<html>
	<head>
		<link href="https://fonts.googleapis.com/css?family=Abril+Fatface|Share+Tech+Mono|Bungee+Shade|Cinzel:400,700|Cute+Font|Faster+One|Monoton|Permanent+Marker|Quicksand:400,600,700|Special+Elite|Vibes&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
		<link href="./style.css" rel="stylesheet">
		<script src="./app.js"></script>
	</head>
	<body style="display:none;">
		<div id="front-center">
			<input type="text" name="" id="filter" autofocus autocomplete="off">
			<div class="footer">
				<span class="c">© 2019 x1n13y84issmd42</span>
				<span class="pipe"></span>
				<a href="https://github.com/x1n13y84issmd42/70015">GitHub</a>
				<span class="pipe"></span>
				<span class="c">With elitism in ♥</span>
			</div>
		</div>

		<script>
			let config = new LSConfig();
			let bench = new Workbench(config);
		</script>

		<div id="tools">


<div class="tool unfocused col2" id="base64" data-tag="base64">
	<div class="preview"><h1>Base64</h1></div>
	<div class="controls smaller">
		<section id="base64-base64">
			<label for="base64-base64-in">Base64-encoded string</label>
			<textarea id="base64-base64-in" autofocus tabindex="21" rows="8"></textarea>
			<div class="undercontrols">
				<div class="menu switch">
					<span>Reuse<i class="fas fa-recycle"></i></span>
					<div>
						<a data-to="hasher" data-value-from="base64" data-value-as="input">Hash it</a>
					</div>
				</div>
				<a class="copy" data-from="base64-base64-in"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
		
		<div class="bothways">It works ⇃both↾ ways.</div>
		
		<section id="base64-ascii">
			<label for="base64-ascii-in">ASCII string</label>
			<textarea id="base64-ascii-in" tabindex="22" onFocus="this.tabIndex=20;" onBlur="this.tabIndex=22;" rows="8"></textarea>
			<div class="undercontrols">
				<div class="menu switch">
					<span>Reuse<i class="fas fa-recycle"></i></span>
					<div>
						<a data-to="hasher" data-value-from="ascii" data-value-as="input">Hash it</a>
					</div>
				</div>
				<a class="copy" data-from="base64-ascii-in"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
	</div>

	<script>
		class TBase64 extends Tool {
			constructor(id) {
				super(id);

				this.inBase64 = this.Section('base64').Input();
				this.inAscii = this.Section('ascii').Input();

				this.inBase64.oninput = () => this.decode();
				this.inAscii.oninput = () => this.encode();
			}

			decode() {
				this.inAscii.value = atob(this.inBase64.value);
			};
			
			encode() {
				this.inBase64.value = btoa(this.inAscii.value);
			};

			import(data) {
				if (data.ascii) {
					this.inAscii.value = data.ascii;
					this.encode();
				}
				
				if (data.base64) {
					this.base64.value = data.base64;
					this.decode();
				}
			}
		}

		bench.add(new TBase64("base64"));
	</script>
</div>


<div class="tool unfocused col2" id="hasher" data-tag="hash md5 sha des">
	<div class="preview"><h1>Hashes &amp; ciphers</h1></div>
	<div class="controls smaller">
		<label for="hasher-input">Input</label>
		<input type="text" id="hasher-input" autofocus tabindex="21" />

		<div class="checksums subsection"></div>
		
		<div class="hashes subsection"></div>
		
		<label for="hasherKeyInput">Encryption key</label>
		<input type="text" class="hasherKeyInput" id="hasherKeyInput" autofocus tabindex="21" />
		<div class="ciphers subsection"></div>
	</div>

	<script src="./node_modules/crypto-js/crypto-js.js?dontcachemepls"></script>
	<script src="./node_modules/js-crc/build/crc.min.js?dontcachemepls"></script>

	<script>
		class THasher extends Tool {
			constructor(id) {
				super(id);

				this.input = this.$$('input');
				this.keyInput = this.$('.hasherKeyInput')[0];

				this.keyInput.oninput = this.input.oninput = () => this.hash();
			}

			hash() {
				let checksums = this.$(".checksums")[0];
				let hashes = this.$(".hashes")[0];
				let ciphers = this.$(".ciphers")[0];

				this.removeChildren(checksums);
				this.removeChildren(hashes);
				this.removeChildren(ciphers);

				checksums.appendChild(this.Component('sectionLabel', "Checksums"));
				checksums.appendChild(this.Component('hash', "CRC16", crc16(this.input.value)));
				checksums.appendChild(this.Component('hash', "CRC32", crc32(this.input.value)));
				
				hashes.appendChild(this.Component('sectionLabel', "Hashes"));
				hashes.appendChild(this.Component('hash', "MD5", '' + CryptoJS.MD5(this.input.value)));
				hashes.appendChild(this.Component('hash', "SHA1", '' + CryptoJS.SHA1(this.input.value)));
				hashes.appendChild(this.Component('hash', "SHA3", '' + CryptoJS.SHA3(this.input.value)));
				hashes.appendChild(this.Component('hash', "SHA256", '' + CryptoJS.SHA256(this.input.value)));
				
				ciphers.appendChild(this.Component('sectionLabel', "Ciphers"));
				let aes = CryptoJS.AES.encrypt(this.input.value, this.keyInput.value, {keySize: 128});
				let des = CryptoJS.DES.encrypt(this.input.value, this.keyInput.value, {keySize: 128});
				// console.log(aes);
				// console.log(aes.key.toString());
				// console.log(aes.iv.toString());
				// console.log(aes.ciphertext.toString());
				// console.log(aes.key);
				// console.log(aes.iv);
				// console.log(aes.ciphertext);
				ciphers.appendChild(this.Component('hash', "AES", aes.ciphertext.toString()));
				ciphers.appendChild(this.Component('hash', "DES", des.ciphertext.toString()));
			};

			import(data) {
				if (data.input) {
					this.T(this.$$('input'), data.input);
					this.hash();
				}
			}
		}

		bench.add(new THasher("hasher"));
	</script>

	<div class="components">
		<h1 class="sectionLabel" data-arg="0"></h1>

		<div class="hash kvpair">
			<span class="label" data-arg="0"></span>
			<span class="value copy" data-arg="1"></span>
		</div>
	</div>
</div>


<div class="tool unfocused col3" id="json" data-tag="json format">
	<div class="preview"><h1>Format JSON</h1></div>
	<div class="controls smaller">
		<section id="json-input">
			<label for="json-input-in">JSON input</label>
			<textarea id="json-input-in" autofocus spellcheck="false" style="margin-bottom:0;" rows="5"></textarea>
			<div class="undercontrols">
				<p class="jsonErr error inset"><i class="fas fa-exclamation-circle"></i><span>&nbsp;</span></p>
				<div class="menu switch">
					<span>Reuse<i class="fas fa-recycle"></i></span>
					<div>
						<a data-to="jsonyaml" data-value-from="input" data-value-as="json">Convert it to YAML</a>
						<a data-to="base64" data-value-from="input" data-value-as="ascii">Base64-encode it</a>
					</div>
				</div>
			</div>
		</section>
		
		<section id="json-1liner" class="disabled">
			<label for="json-1liner-in">One-liner JSON</label>
			<div class="overcontrols">
				<label for="json-1liner-quote-identifiers">
					<input type="checkbox" name="json-1liner-quote-identifiers" id="json-1liner-quote-identifiers" checked>
					Quote names
				</label>
				<label for="json-1liner-escape-quotes">
					<input type="checkbox" name="json-1liner-escape-quotes" id="json-1liner-escape-quotes">
					Escape the quotes
				</label>
			</div>
			<input type="text" id="json-1liner-in" spellcheck="false" disabled>
			<div class="undercontrols">
				<div class="menu switch">
					<span>Reuse<i class="fas fa-recycle"></i></span>
					<div>
						<a data-to="jsonyaml" data-value-from="1liner" data-value-as="json">Convert it to YAML</a>
						<a data-to="base64" data-value-from="1liner" data-value-as="ascii">Base64-encode it</a>
					</div>
				</div>
				<a class="copy" data-from="json-1liner"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
		
		<section id="json-pretty" class="disabled">
			<label for="json-pretty-in">Pretty JSON</label>
			<div class="overcontrols">
				<label for="">Indent with</label>
				<label for="json-pretty-indent-tabs"><input type="radio" name="json-pretty-indent" id="json-pretty-indent-tabs" value="	" checked>tabs</label>
				<label for="json-pretty-indent-4spaces"><input type="radio" name="json-pretty-indent" id="json-pretty-indent-4spaces" value="    ">4 spaces</label>
				<label for="json-pretty-indent-2spaces"><input type="radio" name="json-pretty-indent" id="json-pretty-indent-2spaces" value="  ">2 spaces</label>
			</div>
			<textarea id="json-pretty-in" rows="8" spellcheck="false" disabled></textarea>
			<div class="undercontrols">
				<div class="menu switch">
					<span>Reuse<i class="fas fa-recycle"></i></span>
					<div>
						<a data-to="jsonyaml" data-value-from="pretty" data-value-as="json">Convert it to YAML</a>
						<a data-to="base64" data-value-from="pretty" data-value-as="ascii">Base64-encode it</a>
					</div>
				</div>
				<a class="copy" data-from="json-pretty-in"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
	</div>
	
	<script>
		class TJSON extends Tool {
			constructor(id) {
				super(id);

				this.inJSON = this.Section('input').Input();
				this.outPretty = this.Section('pretty').Input();
				this.out1liner = this.Section('1liner').Input();

				this.indentRadios = this.$('input[name=json-pretty-indent]');
				this.quoteCheck = this.Section('1liner').$$('quote-identifiers');
				this.escapeQuotesCheck = this.Section('1liner').$$('escape-quotes');

				let update = () => {
					this.update();
				}
				
				let switches = this.$('input[type=radio],input[type=checkbox]');
				for (let s of switches) {
					s.onchange = update;
				}

				this.inJSON.oninput = update;
			}

			import(data) {
				data.json && (this.$$('json', data.json));
			}

			update() {
				try {
					let v = JSON.parse(this.inJSON.value);
					this.Section('input').Error(undefined);
					this.prettyPrint(v);
					this.oneliner(v);
					this.Section('1liner').Enable();
					this.Section('pretty').Enable();
				} catch (e) {
					this.Section('input').Error(e.message);
					this.outPretty.value = this.out1liner.value = '¯\\_(ツ)_/¯';
					this.Section('1liner').Disable();
					this.Section('pretty').Disable();
				}
			}

			prettyPrint(v) {
				if (v) {
					let indent = "\t";
					for (let r of this.indentRadios) {
						if (r.checked) {
							indent = r.value;
						}
					}

					this.outPretty.value = JSON.stringify(v, null, indent);
					this.outPretty.rows = this.outPretty.value.split("\n").length;
				}
			}

			oneliner(v) {
				if (v) {
					this.out1liner.value = JSON1Liner(undefined, v, this.quoteCheck.checked, this.escapeQuotesCheck.checked);
				}
			}

			import(data) {
				if (data.input) {
					this.inJSON.value = data.input;
					this.update();
				}
			}
		}

		function JSON1Liner(name, v, quoteNames, escapeQuotes) {
			let quote = (s) => escapeQuotes ? `\\"${s}\\"` : `"${s}"`;
			let namePrefix = '';
			name && (namePrefix = name) && quoteNames && (namePrefix = quote(namePrefix));
			namePrefix && (namePrefix += ':');

			switch (typeof v) {
				case 'string':
					return namePrefix + quote(v);

				case 'number':
					return namePrefix + v.toString();

				case 'object':
					if (v instanceof Array) {
						return `${namePrefix}[` + v.map((vv) => JSON1Liner(undefined, vv, quoteNames, escapeQuotes)).join(',') + "]";
					} else {
						return `${namePrefix}{` + Object.keys(v).map((vk) => JSON1Liner(vk, v[vk], quoteNames, escapeQuotes)) + "}";
					}
					break
			}
		}

		bench.add(new TJSON('json'));
	</script>

	<style>
		#json .subcontrols {
			width: 1000px;
		}
	</style>
</div>


<div class="tool unfocused" id="jsonyaml" data-tag="json yaml">
	<div class="preview">
		<h1>JSON &#x2942 YAML</h1>
	</div>
	<div class="controls smaller">
		<section id="jsonyaml-json">
			<label for="jsonyaml-json-in">JSON</label>

			<div class="overcontrols">
				<label for="">Indent with</label>
				<label for="json-pretty-indent-tabs"><input type="radio" name="json-pretty-indent" id="json-pretty-indent-tabs" value="	" checked>tabs</label>
				<label for="json-pretty-indent-4spaces"><input type="radio" name="json-pretty-indent" id="json-pretty-indent-4spaces" value="    ">4 spaces</label>
				<label for="json-pretty-indent-2spaces"><input type="radio" name="json-pretty-indent" id="json-pretty-indent-2spaces" value="  ">2 spaces</label>
			</div>
			
			<textarea id="jsonyaml-json-in" cols="30" rows="9"></textarea>
			
			<div class="undercontrols">
				<p class="error"><i class="fas fa-exclamation-circle"></i><span>&nbsp;</span></p>
				<div class="menu switch">
					<span>Reuse<i class="fas fa-recycle"></i></span>
					<div>
						<a data-to="json" data-value-from="json" data-value-as="input">Format it</a>
					</div>
				</div>
				<a class="copy" data-from="jsonyaml-json-in"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
		
		<div class="bothways">It works ⇃both↾ ways.</div>
		
		<section id="jsonyaml-yaml">
			<label for="jsonyaml-yaml-in">YAML</label>

			<textarea id="jsonyaml-yaml-in" cols="30" rows="9"></textarea>

			<div class="undercontrols">
				<p class="error inset"><i class="fas fa-exclamation-circle"></i><span>&nbsp;</span></p>
				<a class="copy" data-from="jsonyaml-yaml-in"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
	</div>

	<script src="./node_modules/js-yaml/dist/js-yaml.min.js"></script>

	<script>
		class TJSONYAML extends Tool {
			constructor(id) {
				super(id);

				this.json = this.Section('json').Input();
				this.yaml = this.Section('yaml').Input();

				this.json.oninput = () => this.toYAML();
				this.yaml.oninput = () => this.toJSON();

				this.indentRadios = this.$('input[name=json-pretty-indent]');

				for (let s of this.switches) {
					s.onchange = () => this.toJSON();
				}
			}

			toYAML() {
				try {
					this.yaml.value = jsyaml.safeDump(JSON.parse(this.json.value));
					this.Section('json').Error(undefined).Enable();
					this.Section('yaml').Error(undefined).Enable();
				} catch (e) {
					this.Section('json').Error(e.message);
					this.yaml.value = '¯\\_(ツ)_/¯';
					this.Section('yaml').Disable();
				}
			}
			
			toJSON() {
				let indent = "\t";
				for (let r of this.indentRadios) {
					if (r.checked) {
						indent = r.value;
					}
				}
				
				try {
					this.json.value = JSON.stringify(jsyaml.safeLoad(this.yaml.value), undefined, indent);
					this.Section('json').Error(undefined).Enable();
					this.Section('yaml').Error(undefined).Enable();
				} catch (e) {
					this.Section('yaml').Error(e.message);
					this.json.value = '¯\\_(ツ)_/¯';
					this.Section('json').Disable();
				}
			}

			import(data) {
				if (data.json) {
					this.json.value = data.json;
					this.toYAML();
				}
				
				if (data.yaml) {
					this.yaml.value = data.yaml;
					this.toJSON();
				}
			}
		}

		bench.add(new TJSONYAML('jsonyaml'));
	</script>

	<style>
		#jsonyaml .subcontrols {
			width: 1000px;
		}
	</style>
</div>


<div class="tool unfocused col3" id="unixtime" data-tag="unixtime">
	<div class="preview"><h1>Unixtime</h1></div>
	<div class="controls smaller">
		<section id="unixtime-ts">
			<label for="unixtime-ts-in">Unixtime</label>
			<input type="text" class="inTimestamp" id="unixtime-ts-in" autofocus>
			<div class="undercontrols">
				<p class="error"><i class="fas fa-exclamation-circle"></i><span>&nbsp;</span></p>
			</div>
		</section>

		<section id="unixtime-formatted">
			<div class="left l35">
				<div class="typographyDate copy">
					<p class="l10">&nbsp;</p>
				</div>
			</div>
			
			<div class="right r65">
				<div class="dates"></div>
			</div>
		</section>
	</div>

	<script>
		class TUnixtime extends Tool {
			constructor(id) {
				super(id);

				this.inTS = this.Section('ts').Input();
				this.dates = this.$('.dates')[0];

				this.inTS.oninput = () => this.convert();
			}

			convert() {
				this.removeChildren(this.dates);

				try {
					let d = new Date();
					d.setTime(this.inTS.value.trim() + "000")

					this.typographyDate(d);
					this.dates.appendChild(this.Component("sectionLabel", "Formatted"))
					this.dates.appendChild(this.Component("kvpair", "ISO 8601", d.toISOString()))
					this.dates.appendChild(this.Component("kvpair", "Date.toString()", d.toString()))
					this.Section('ts').Error(undefined);
					this.Section('formatted').Show();
				} catch (err) {
					this.Section('ts').Error(err.message);
					this.Section('formatted').Hide();
				}
			}

			typographyDate(d) {
				let timezone = undefined;
				let eTZT = document.createElement("p");
				let opts = {
					timezone,
					weekday: "long",
					month: "long",
					year: "numeric",
					day: "numeric",
					hour: "numeric",
					minute: "numeric",
					second: "numeric",
				};

				let locale = "en-US";
				let weekday = d.toLocaleDateString(locale, {timezone, weekday: "long"});
				let weekdayClass = "l" + weekday.length;
				let weekdayE = document.createElement("p");
				let month = d.toLocaleDateString(locale, {timezone, month: "long", day: "numeric"});
				let monthClass = "l" + month.length;
				let monthE = document.createElement("p");
				let year = d.toLocaleDateString(locale, {timezone, year: "numeric"});
				let yearClass = "l" + year.length;
				let yearE = document.createElement("p");
				let time = d.toLocaleDateString(locale, {timezone, hour: "numeric", minute: "numeric", second: "numeric"}).split(', ')[1] || "00";
				let timeClass = "l" + time.length;
				let timeE = document.createElement("p");

				weekdayE.classList.add("weekday", weekdayClass);
				weekdayE.innerHTML = weekday;
				monthE.classList.add("month", monthClass);
				monthE.innerHTML = month;
				yearE.classList.add("year", yearClass);
				yearE.innerHTML = year;
				timeE.classList.add("time", timeClass);
				timeE.innerHTML = time;

				let tdE = this.$(".typographyDate")[0];
				this.removeChildren(tdE)

				tdE.dataset.value = `${weekday}, ${month} ${year}, ${time}`;

				tdE.appendChild(weekdayE);
				tdE.appendChild(monthE);
				tdE.appendChild(yearE);
				tdE.appendChild(timeE);
			}
		}

		bench.add(new TUnixtime("unixtime"));

	</script>

	<style>
		.timezones > p {
			opacity: 0;
			font-family: Quicksand;
		}

		.timezones > p.v {
			opacity: 1;
			font-family: Quicksand;
			transition: all 400ms ease-in-out;
			-webkit-transition: all 400ms ease-in-out;
			-moz-transition: all 400ms ease-in-out;
			-o-transition: all 400ms ease-in-out;
		}
									
		.timezones > p > i {
			margin-right: 20px;
			font-family: inherit;
			display: inline-block;
			width: 110px;
			font-style: normal;
		}

		.timezones > p > span {
			font-family: inherit;
			font-size: 125%;
		}

		#unixtime .typographyDate {
			font-family: Share Tech Mono;
			width: 370px;
		}
		
		#unixtime .typographyDate:hover {
			transform: scale(1.05);
			color: #00BBFF;
			transition: all 100ms ease-in-out;
		}

		#unixtime .typographyDate > * {
			font-family: inherit;
			line-height: 90%;
			cursor: pointer;
		}

		#unixtime .typographyDate > .l1 {font-size: 500.00pt;}
		#unixtime .typographyDate > .l2 {font-size: 250.00pt;}
		#unixtime .typographyDate > .l3 {font-size: 166.67pt;}
		#unixtime .typographyDate > .l4 {font-size: 125.00pt;}
		#unixtime .typographyDate > .l5 {font-size: 100.00pt;}
		#unixtime .typographyDate > .l6 {font-size: 83.33pt;}
		#unixtime .typographyDate > .l7 {font-size: 71.43pt;}
		#unixtime .typographyDate > .l8 {font-size: 62.50pt;}
		#unixtime .typographyDate > .l9 {font-size: 55.56pt;}
		#unixtime .typographyDate > .l10 {font-size: 50.00pt;}
		#unixtime .typographyDate > .l11 {font-size: 45.45pt;}
		#unixtime .typographyDate > .l12 {font-size: 41.67pt;}
		#unixtime .typographyDate > .l13 {font-size: 38.46pt;}
		#unixtime .typographyDate > .l14 {font-size: 35.71pt;}
		#unixtime .typographyDate > .l15 {font-size: 33.33pt;}
		#unixtime .typographyDate > .l16 {font-size: 31.25pt;}
		#unixtime .typographyDate > .l17 {font-size: 29.41pt;}
		#unixtime .typographyDate > .l18 {font-size: 27.78pt;}
		#unixtime .typographyDate > .l19 {font-size: 26.32pt;}
		#unixtime .typographyDate > .l20 {font-size: 25.00pt;}
		#unixtime .typographyDate > .l21 {font-size: 23.81pt;}
		#unixtime .typographyDate > .l22 {font-size: 22.73pt;}
		#unixtime .typographyDate > .l23 {font-size: 21.74pt;}
		#unixtime .typographyDate > .l24 {font-size: 20.83pt;}
		#unixtime .typographyDate > .l25 {font-size: 20.00pt;}
		#unixtime .typographyDate > .l26 {font-size: 19.23pt;}
		#unixtime .typographyDate > .l27 {font-size: 18.52pt;}
		#unixtime .typographyDate > .l28 {font-size: 17.86pt;}
		#unixtime .typographyDate > .l29 {font-size: 17.24pt;}
		#unixtime .typographyDate > .l30 {font-size: 16.67pt;}
		#unixtime .typographyDate > .l31 {font-size: 16.13pt;}
		#unixtime .typographyDate > .l32 {font-size: 15.63pt;}
		#unixtime .typographyDate > .l33 {font-size: 15.15pt;}
		#unixtime .typographyDate > .l34 {font-size: 14.71pt;}
		#unixtime .typographyDate > .l35 {font-size: 14.29pt;}
		#unixtime .typographyDate > .l36 {font-size: 13.89pt;}
		#unixtime .typographyDate > .l37 {font-size: 13.51pt;}
		#unixtime .typographyDate > .l38 {font-size: 13.16pt;}
		#unixtime .typographyDate > .l39 {font-size: 12.82pt;}
		#unixtime .typographyDate > .l40 {font-size: 12.50pt;}
		#unixtime .typographyDate > .l41 {font-size: 12.20pt;}
		#unixtime .typographyDate > .l42 {font-size: 11.90pt;}
		#unixtime .typographyDate > .l43 {font-size: 11.63pt;}
		#unixtime .typographyDate > .l44 {font-size: 11.36pt;}
		#unixtime .typographyDate > .l45 {font-size: 11.11pt;}
		#unixtime .typographyDate > .l46 {font-size: 10.87pt;}
		#unixtime .typographyDate > .l47 {font-size: 10.64pt;}
		#unixtime .typographyDate > .l48 {font-size: 10.42pt;}
		#unixtime .typographyDate > .l49 {font-size: 10.20pt;}
		#unixtime .typographyDate > .l50 {font-size: 10.00pt;}
	</style>

	<div class="components">
		<h1 class="sectionLabel" data-arg="0"></h1>

		<div class="kvpair">
			<span class="label" data-arg="0"></span>
			<a class="value copy" data-arg="1" style="padding-bottom:2em;"></a>
		</div>
	</div>
</div>


<div class="tool unfocused col1" id="urldecode" data-tag="url trans encode decode">
	<div class="preview"><h1>Transcode URL</h1></div>
	<div class="controls smaller">
		<section>
			<label for="urldecode-encinput">URL-encoded string</label>
			<input type="text" class="encinput" id="urldecode-encinput" autofocus tabindex="11">
			<div class="undercontrols">
				<a class="copy" data-from="urldecode-encinput"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>

		<div class="bothways">It works ⇃both↾ ways.</div>

		<section>
			<label for="urldecode-encinput">ASCII string</label>		
			<input type="text" class="decinput" id="urldecode-decinput" tabindex="12" onFocus="this.tabIndex=10;" onBlur="this.tabIndex=12;">
			<div class="undercontrols">
				<a class="copy" data-from="urldecode-decinput"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
	</div>

	<script>
		class TURLTranscoder extends Tool {
			constructor(id) {
				super(id)

				this.encoded = this.$('.encinput')[0];
				this.decoded = this.$('.decinput')[0];
				this.encoded.oninput = () => this.decode();
				this.decoded.oninput = () => this.encode();
			}
	
			decode() {
				this.decoded.value = decodeURIComponent(this.encoded.value);
			};
			
			encode() {
				this.encoded.value = encodeURIComponent(this.decoded.value);
			};

		}

		bench.add(new TURLTranscoder("urldecode"));

	</script>
</div>


<div class="tool unfocused" id="urlparse" data-tag="urlparse">
	<div class="preview"><h1>Parse URL</h1></div>
	<div class="controls smaller">
		<section id="urlparse-url">
			<label for="urlparse-url-in">URL</label>
			<input type="text" id="urlparse-url-in" spellcheck="false" autofocus>
			<div class="undercontrols">
				<p class="error"><i class="fas fa-exclamation-circle"></i><span>&nbsp;</span></p>
			</div>
		</section>

		<section id="urlparse-fields">
			<div class="fields">
			</div>
		</section>
	</div>

	<script>
		class TURLParser extends Tool {
			constructor(id) {
				super(id);
				this.URL = this.Section("url").Input();

				this.URL.oninput = () => {
					let fields = this.$(".fields")[0];
					while (fields.firstChild)
						fields.removeChild(fields.firstChild);

					let url;

					try {
						url = new URL(this.URL.value);
						this.Section("url").Error(undefined);
						this.Section('fields').Show();
					} catch (err) {
						this.Section("url").Error(err.message);
						this.Section('fields').Hide();
						return;
					}
					
					if (url.protocol) {
						fields.appendChild(this.Component("urlprop", "Protocol", url.protocol));
					}

					if (url.hostname) {
						fields.appendChild(this.Component("urlprop", "Domain", url.hostname));
					}

					if (url.username) {
						fields.appendChild(this.Component("urlprop", "Username", url.username));
					}

					if (url.password) {
						fields.appendChild(this.Component("urlprop", "Password", url.password));
					}

					if (url.path) {
						fields.appendChild(this.Component("urlprop", "Path", url.path));
					} else if (url.pathname) {
						fields.appendChild(this.Component("urlprop", "Path", url.pathname));
					}

					if (url.port) {
						fields.appendChild(this.Component("urlprop", "Port", url.port));
					}

					if (url.hash) {
						fields.appendChild(this.Component("urlprop", "Hash", url.hash));
					}

					/* if (url.search) {
						fields.appendChild(this.Component("urlprop", "Query string", url.search));
					} */
					
					if (url.search && url.searchParams) {
						fields.appendChild(this.Component("section", "Query"));
						let sp = this.improveSearchParams(url.searchParams);
						for (let spn in sp) {
							let spv = sp[spn];
							if (spv instanceof Array) {
								let t = true;
								for (let spvv of spv) {
									fields.appendChild(this.Component("urlprop-sub", t ? (t = false, spn) : "", spvv));
								}
							} else {
								fields.appendChild(this.Component("urlprop-sub", spn, spv));
							}
						}
					}
				};
			}
			
			improveSearchParams(urlsp) {
				let res = {};
				for (let e of urlsp.entries()) {
					let qspn = e[0];
					let qspv = e[1];

					if (qspn.substr(-2) == '[]') {
						qspn = qspn.substr(0, qspn.length - 2);
						res[qspn] || (res[qspn] = []);
						res[qspn].push(qspv);
					} else {
						res[qspn] = qspv;
					}
				}

				return res;
			}
		}

		bench.add(new TURLParser("urlparse"));
		
	</script>

	<div class="components">
		<div class="urlprop kvpair">
			<span class="label" data-arg="0"></span>
			<span class="value copy" data-arg="1"></span>
		</div>
		
		<div class="kvpair section">
			<span class="label" data-arg="0"></span>
			<span class="value">&nbsp;</span>
		</div>
		
		<div class="urlprop-sub kvpair sub">
			<span class="label" data-arg="0"></span>
			<span class="value copy" data-arg="1"></span>
		</div>
	</div>
</div>


<div class="tool unfocused col1" id="xml" data-tag="xml xpath">
	<div class="preview"><h1>XML &amp; Xpath</h1></div>
	<div class="controls smaller">
		<section id="xml-xml">
			<label for="xml-xml-in">XML input</label>
			<textarea id="xml-xml-in" autofocus spellcheck="false" style="margin-bottom:0;" rows="5"></textarea>
			<div class="undercontrols">
				<p class="error"><i class="fas fa-exclamation-circle"></i><span>&nbsp;</span></p>
				<div class="menu switch">
					<span>Reuse<i class="fas fa-recycle"></i></span>
					<div>
						<a data-to="base64" data-value-from="xml" data-value-as="ascii">Base64-encode it</a>
					</div>
				</div>
			</div>
		</section>

		<section id="xml-xpath">
			<label for="xml-xpath-in">XPath query</label>
			<input type="text" id="xml-xpath-in" spellcheck="false" style="margin-bottom:0;" />
			<div class="undercontrols">
				<p class="error"><i class="fas fa-exclamation-circle"></i><span>&nbsp;</span></p>
				<a class="copy" data-from="xml-xpath-in"><span>Copy</span><i class="far fa-copy"></i></a>
			</div>
		</section>
		
		<section id="xml-nice" class="hidden">
			<label>XML structure</label>
			<div id="xml-nice-root"></div>
		</section>
	</div>

	<script>
		class TXML extends Tool {
			constructor(id) {
				super(id)

				this.xml = this.Section('xml').Input();
				this.xpath = this.Section('xpath').Input();
				this.xmlNice = this.Section('nice').$$('root');

				this.xml.oninput = () => this.update();
				this.xpath.oninput = () => this.update();
			}

			parseXML(s) {
				let parser = new DOMParser();
				let xml = parser.parseFromString(s, "text/xml");

				this.checkXMLParserErrors(xml);

				return xml;
			}

			//	DOMParser.parseFromString() won't throw or report errorss in any other way.
			//	Instead it creates a document with a markup in it, where an information about error is stored.
			//	Wat.
			checkXMLParserErrors(xml) {
				let parserError = xml.getElementsByTagName("parsererror")[0];

				if (parserError) {
					let errors = parserError.getElementsByTagName("div");
					if (errors.length) {
						throw Array.from(errors).map(en => en.innerText).join('<br/>');
					}
				}
			}

			update() {
				let xml;
				let found = [];

				try {
					xml = this.parseXML(this.xml.value);
					this.Section('xml').Error();
					this.Section('xpath').Enable();
					this.Section('nice').Show();
				} catch(err) {
					this.Section('xml').Error(err);
					this.Section('xpath').Disable();
					this.Section('nice').Hide();
				}
				
				try {
					found = this.queryXPath(xml, this.xpath.value);
					this.Section('xpath').Error();
					this.Section('nice').Show();
				} catch(err) {
					this.Section('xpath').Error(err.message);
					this.Section('nice').Hide();
				}

				while(this.xmlNice.firstChild) {
					this.xmlNice.removeChild(this.xmlNice.firstChild)
				}

				this.renderXML(xml, this.xmlNice, found);
			}

			queryXPath(doc, xpath) {
				var found = [];

				if (doc && xpath) {
					var xpe = new XPathEvaluator();
					var result = xpe.evaluate(xpath, doc);
					var res;
					while (res = result.iterateNext()) {
						found.push(res);
					}
					
					console.log("Found XML nodes: ", found);
				}

				return found;
			}

			nodeStr(node) {
				let str = node.nodeName;
				let attributes = '';
				let position = 0;

				if (node.attributes) {
					let attrs = [];
					for (let aI = 0; aI < node.attributes.length; aI++) {
						let a = node.attributes[aI];
						attrs.push(`${a.name}=${a.nodeValue}`);
					}

					attributes = `(${attrs.join(',')})`;
				}

				let n = node;
				while (n.previousSibling) {
					n = n.previousSibling;
					position++;
				}

				return `${str}#${position}${attributes}`;
			}

			isFound(node, foundNodes) {
				let nodePath = this.getNodePath(node);

				for (let fn of foundNodes) {
					let fnPath = this.getNodePath(fn);

					if (nodePath === fnPath) {
						return true;
					}
				}

				return false;
			}

			getNodePath(xmlNode) {
				let p = [];
				let n = xmlNode;
				while (n) {
					p.push(this.nodeStr(n));
					n = n.parentNode || n.ownerElement;
				}
				return p.join(',');
			}

			createXMLNode(classes, value) {
				let n = document.createElement('div');
				classes && (n.className = classes.join(' '));
				value && (n.innerHTML = value);
				return n;
			}

			renderXML(xml, E, foundXML) {
				if (! xml) {
					return
				}

				let xmlE = document.createElement('div');
				xmlE.classList.add("xml-node");

				switch (xml.nodeType) {
					case Node.ELEMENT_NODE:
						let xattrs = [];

						let xt = this.createXMLNode(['tag']);
						let xto = this.createXMLNode(['opening']);
						let xtn = this.createXMLNode(['name'], xml.nodeName);

						xt.appendChild(xto);
						xt.appendChild(xtn);

						for (let attrI = 0; attrI < xml.attributes.length; attrI++) {
							let attr = xml.attributes[attrI];

							let xattrName = this.createXMLNode(['name'], attr.name);
							let xattrEq = this.createXMLNode(['eq']);
							let xattrValue = this.createXMLNode(['value'], `"${attr.nodeValue}"`);
							let xattr = this.createXMLNode(['attr']);
							xattr.appendChild(xattrName);
							xattr.appendChild(xattrEq);
							xattr.appendChild(xattrValue);

							if (this.isFound(attr, foundXML)) {
								// console.log("Found an attribute!", attr);
								xattr.classList.add('found');
							}

							xt.appendChild(xattr);
						}

						if (xml.childNodes.length) {
							xt.appendChild(this.createXMLNode(['closing']))
						} else {
							xt.appendChild(this.createXMLNode(['closing-short']))
						}

						xmlE.appendChild(xt);
						xmlE.dataset.xmlName = xml.nodeName;
					break;

					case Node.TEXT_NODE:
						xmlE.classList.add('text');
						xmlE.innerHTML = xml.nodeValue;
					break;
					
					case Node.CDATA_SECTION_NODE:
					break;
				}

				if (this.isFound(xml, foundXML)) {
					// console.log("Found the node!", xml)
					xmlE.classList.add('found');
				}
				
				E.appendChild(xmlE);
				
				for (let xmlCN of xml.childNodes) {
					this.renderXML(xmlCN, xmlE, foundXML);
				}
				
				if (xml.nodeType === 1 && xml.childNodes.length) {
					
					let xt = this.createXMLNode(['tag']);
					xt.appendChild(this.createXMLNode(['opening-closing']));
					xt.appendChild(this.createXMLNode(['name'], xml.nodeName));
					xt.appendChild(this.createXMLNode(['closing']));
					xmlE.appendChild(xt)
				}
			}
		}

		bench.add(new TXML("xml"));

	</script>

	<style>
		#xml-nice .found,
		#xml-nice .found * {
			color: white !important;
			background: #00BBFF !important;
		}

		.xml-node {
			position: relative;
			left: 20px;
			float: left;
			clear: left;
		}
		
		.xml-node.text {
			font-style: italic;
		}

		.xml-node > .tag {
			clear: both;
		}

		.xml-node > .tag > * {
			display: inline-block;
		}
		
		.xml-node > .tag > .name {
			color: #062873;
    		font-weight: bold;
		}
		
		.xml-node > .tag > .opening::after {
			content: "<";
		}
		
		.xml-node > .tag > .opening-closing::after {
			content: "</";
		}
		
		.xml-node > .tag > .closing::after {
			content: ">";
		}
		
		.xml-node > .tag > .closing-short::after {
			content: " />";
		}
		
		.xml-node > .tag > .attr {
			margin-left: 10px;
		}
		
		.xml-node > .tag > .attr > * {
			display: inline-block;
		}
		
		.xml-node > .tag > .attr > .name {
			color: #062873;
		}

		.xml-node > .tag > .attr > .eq:after {
			content: "="
		}

		.xml-node > .tag > .attr > .value {
			font-weight: bold;
			color: #444;
			font-style: italic;
		}
	</style>
</div>


		</div>

		<script>
			function focus(id) {
				bench.focus(id);
			}

			function unfocus(id) {
				bench.unfocus(id);
				window.location.hash = '';
				filter.focus();
			}

			/**
			 * Temporarily applies a class to an element. The class is removed after the specified amount of time passes.
			 * @param {HTMLElement} e An element to style.
			 * @param {string} className A class name to apply temporarily.
			 * @param {number} time A time period the class should be removed after.
			 */
			function tmpStyle(e, className, time) {
				e.classList.add(className);
				setTimeout(() => {
					e.classList.remove(className);
				}, time);
			}

			function copiedFloater(x, y) {
				let fltr = document.createElement('div');
				fltr.classList.add("floater");
				fltr.style.left = (x - 45) + "px";
				fltr.style.top = (y - 35) + "px";
				fltr.innerHTML = 'Copied.';
				document.body.appendChild(fltr);

				setTimeout(() => {
					fltr.classList.add("vanishing");
				}, 0);

				setTimeout(() => {
					document.body.removeChild(fltr);
				}, 1000);
			}

			function onclickCopyToClipboard(e) {
				let from = e.currentTarget;

				//	Looking for a disabled parent.
				let pn = from.parentNode;
				while (pn) {
					if (pn.classList && pn.classList.contains('disabled')) {
						return;
					}
					pn = pn.parentNode;
				}

				if (from.dataset.value) {
					Clipboard.copy(from.dataset.value);
					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
					return;
				}
				
				if (from.dataset.from) {
					from = document.getElementById(from.dataset.from);
				}
				
				if (from) {	
					switch (from.tagName) {
						case "INPUT":
						case "TEXTAREA":
							Clipboard.copy(from.value);
							break;
							
						default:
							Clipboard.copy(from.innerHTML);
							break;
					}

					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
				}
			}

			document.body.onload = () => {
				let filter = document.getElementById("filter");
				filter.oninput = () => {
					bench.filter(filter.value);
				}
				
				filter.onkeydown = (e) => {
					if (e.key == 'Enter') {
						//	Focusing the only matched tool.
						let matched = document.querySelectorAll(".matched");
						if (matched.length == 1) {
							focus(matched[0].id);
							e.preventDefault();
							e.cancelBubble = true;
						}
					} else if (e.key == 'Escape') {
						//	Clearing the filtering.
						filter.value = "";
						bench.filter("");
					}
				}

				//	Copy buttons.
				document.querySelectorAll('.copy').forEach((v, k, p) => {v.onclick = onclickCopyToClipboard});

				//	Autofocusing tools upon page load.
				if (window.location.hash) {
					bench.focus(window.location.hash.substr(1));
				}

				bench.render();
			}
		</script>
	</body>
</html>


