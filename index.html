
<html>
	<head>
		<link href="https://fonts.googleapis.com/css?family=Abril+Fatface|Share+Tech+Mono|Bungee+Shade|Cinzel:400,700|Cute+Font|Faster+One|Monoton|Permanent+Marker|Quicksand:400,600,700|Special+Elite|Vibes&display=swap" rel="stylesheet">
		<link href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" rel="stylesheet">
		<link href="./style.css" rel="stylesheet">
		<script src="./app.js"></script>
	</head>
	<body style="display:none;">
		<div id="front-center">
			<input type="text" name="" id="filter" autofocus autocomplete="off">
			<div class="footer">
				<span class="c">© 2019 x1n13y84issmd42</span>
				<span class="pipe"></span>
				<a href="https://github.com/x1n13y84issmd42/70015">GitHub</a>
				<span class="pipe"></span>
				<span class="c">With elitism in ♥</span>
			</div>
		</div>

		<div id="tools"></div>

		<script>
			let config = new LSConfig();
			let bench = new Workbench(config);
		</script>

		<div id="toolshed">


<tool _id="base64" data-tag="base64" name="Base64">
	<section _id="base64">
		<input type="area" rows="8" label="Base64-encoded string">
		<undercontrols>
			<reuse>
				<hasher input="#base64">Hash it</hasher>
			</reuse>
			<copy from="#base64"></copy>
		</undercontrols>
	</section>

	<div class="bothways">It works ⇃both↾ ways.</div>

	<section _id="ascii">
		<input type="area" rows="8" label="ASCII string">
		<undercontrols>
			<reuse>
				<hasher input="#ascii">Hash it</hasher>
			</reuse>
			<copy from="#ascii"></copy>
		</undercontrols>
	</section>
</tool>

<script>
	(() => {
		class TBase64 extends Tool {
			constructor(id) {
				super(id);

				this.inBase64 = this.Section('base64').Input();
				this.inAscii = this.Section('ascii').Input();

				this.inBase64.oninput = () => this.decode();
				this.inAscii.oninput = () => this.encode();
			}

			decode() {
				this.inAscii.value = atob(this.inBase64.value);
			};
			
			encode() {
				this.inBase64.value = btoa(this.inAscii.value);
			};

			import(data) {
				if (data.ascii) {
					this.inAscii.value = data.ascii;
					this.encode();
				}
				
				if (data.base64) {
					this.base64.value = data.base64;
					this.decode();
				}
			}
		}

		let comp = Component.New('base64');
		window.tools.appendChild(comp);
		bench.add(new TBase64(comp));
	})()
</script>



<tool _id="hasher" data-tag="hash md5 sha des" name="Hashes &amp; ciphers">
	<input type="text" _id="input" autofocus tabindex="21" label="Input"/>

	<div class="checksums subsection"></div>
	<div class="hashes subsection"></div>
	
	<input type="text" class="hasherKeyInput" _id="key" autofocus tabindex="21" label="Encryption key" />

	<div class="ciphers subsection"></div>

	<div class="components">
		<h1 class="sectionLabel" data-arg="0"></h1>
	
		<div class="hash kvpair">
			<span class="label" data-arg="0"></span>
			<span class="value copy" data-arg="1"></span>
		</div>
	</div>
</tool>

<script src="./node_modules/crypto-js/crypto-js.js?dontcachemepls"></script>
<script src="./node_modules/js-crc/build/crc.min.js?dontcachemepls"></script>

<script>
	(() => {
		class THasher extends Tool {
			constructor(id) {
				super(id);

				this.input = this.$$('input');
				this.keyInput = this.$$('key');

				this.keyInput.oninput = this.input.oninput = () => this.hash();
			}

			hash() {
				let checksums = this.$(".checksums")[0];
				let hashes = this.$(".hashes")[0];
				let ciphers = this.$(".ciphers")[0];

				this.removeChildren(checksums);
				this.removeChildren(hashes);
				this.removeChildren(ciphers);

				checksums.appendChild(this.Component('sectionLabel', "Checksums"));
				checksums.appendChild(this.Component('hash', "CRC16", crc16(this.input.value)));
				checksums.appendChild(this.Component('hash', "CRC32", crc32(this.input.value)));
				
				hashes.appendChild(this.Component('sectionLabel', "Hashes"));
				hashes.appendChild(this.Component('hash', "MD5", '' + CryptoJS.MD5(this.input.value)));
				hashes.appendChild(this.Component('hash', "SHA1", '' + CryptoJS.SHA1(this.input.value)));
				hashes.appendChild(this.Component('hash', "SHA3", '' + CryptoJS.SHA3(this.input.value)));
				hashes.appendChild(this.Component('hash', "SHA256", '' + CryptoJS.SHA256(this.input.value)));
				
				ciphers.appendChild(this.Component('sectionLabel', "Ciphers"));
				let aes = CryptoJS.AES.encrypt(this.input.value, this.keyInput.value, {keySize: 128});
				let des = CryptoJS.DES.encrypt(this.input.value, this.keyInput.value, {keySize: 128});
				// console.log(aes);
				// console.log(aes.key.toString());
				// console.log(aes.iv.toString());
				// console.log(aes.ciphertext.toString());
				// console.log(aes.key);
				// console.log(aes.iv);
				// console.log(aes.ciphertext);
				ciphers.appendChild(this.Component('hash', "AES", aes.ciphertext.toString()));
				ciphers.appendChild(this.Component('hash', "DES", des.ciphertext.toString()));
			};

			import(data) {
				if (data.input) {
					this.T(this.$$('input'), data.input);
					this.hash();
				}
			}
		}

		let comp = Component.New('hasher');
		window.tools.appendChild(comp);
		bench.add(new THasher(comp));
	})()
</script>



		</div>

		<div id="ui-stash">
			<dialog data-purpose="social" id="share" title="${title}">
				<section id="link">
					<input type="text" label="<<${title} a link>>" value="${value}" />
					<undercontrols>
						<error></error>
						<copy from="link"></copy>
						<reuse>
							<urlparse url="share-link-in">Parse it</urlparse>
							<urldecode ascii="share-link-in">URL-encode it</urldecode>
							<base64 ascii="share-link-in">Base64-encode it</base64>
							<hasher input="share-link-in">Hash it!</hasher>
						</reuse>
					</undercontrols>
				</section>
			</dialog>
		</div>

		<script>
			function focus(id) {
				bench.focus(id);
			}

			function unfocus(id) {
				bench.unfocus(id);
				window.location.hash = '';
				filter.focus();
			}

			/**
			 * Temporarily applies a class to an element. The class is removed after the specified amount of time passes.
			 * @param {HTMLElement} e An element to style.
			 * @param {string} className A class name to apply temporarily.
			 * @param {number} time A time period the class should be removed after.
			 */
			function tmpStyle(e, className, time) {
				e.classList.add(className);
				setTimeout(() => {
					e.classList.remove(className);
				}, time);
			}

			function copiedFloater(x, y) {
				let fltr = document.createElement('div');
				fltr.classList.add("floater");
				fltr.style.left = (x - 45) + "px";
				fltr.style.top = (y - 35) + "px";
				fltr.innerHTML = 'Copied.';
				document.body.appendChild(fltr);

				setTimeout(() => {
					fltr.classList.add("vanishing");
				}, 0);

				setTimeout(() => {
					document.body.removeChild(fltr);
				}, 1000);
			}

			function onclickCopyToClipboard(e) {
				let from = e.currentTarget;

				//	Looking for a disabled parent.
				let pn = from.parentNode;
				while (pn) {
					if (pn.classList && pn.classList.contains('disabled')) {
						return;
					}
					pn = pn.parentNode;
				}

				if (from.dataset.value) {
					Clipboard.copy(from.dataset.value);
					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
					return;
				}
				
				if (from.dataset.from) {
					from = document.getElementById(from.dataset.from);
				}
				
				if (from) {	
					switch (from.tagName) {
						case "INPUT":
						case "TEXTAREA":
							Clipboard.copy(from.value);
							break;
							
						default:
							Clipboard.copy(from.innerHTML);
							break;
					}

					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
				}
			}

			document.body.onload = () => {
				// let dialogE = Component.New('share', {
				// 	title: 'Share',
				// 	value: `${window.location.pathname}#yolo2020`
				// });
				// document.body.appendChild(dialogE);

				let filter = document.getElementById("filter");
				filter.oninput = () => {
					bench.filter(filter.value);
				}
				
				filter.onkeydown = (e) => {
					if (e.key == 'Enter') {
						//	Focusing the only matched tool.
						let matched = document.querySelectorAll(".matched");
						if (matched.length == 1) {
							focus(matched[0].id);
							e.preventDefault();
							e.cancelBubble = true;
						}
					} else if (e.key == 'Escape') {
						//	Clearing the filtering.
						filter.value = "";
						bench.filter("");
					}
				}

				//	Copy buttons.
				document.querySelectorAll('.copy').forEach((v, k, p) => {v.onclick = onclickCopyToClipboard});

				//	Autofocusing tools upon page load.
				if (window.location.hash) {
					bench.focus(window.location.hash.substr(1));
				}

				bench.render();
			}
		</script>
	</body>
</html>


