		</div>
		<!-- #toolshed, opened in toolshed.html -->

		<script>

			XUI.render(window.menu);

			const doubleEscTime = 200;
			let lastTimeEscPressed = new Date().getTime();
			
			document.body.onkeydown = (e) => {
				if (e.key == 'Escape') {
					let now = new Date().getTime();
					e.preventDefault();

					if (now - lastTimeEscPressed <= doubleEscTime) {
						bench.clear();
					} else {
						bench.back();
					}

					lastTimeEscPressed = now;
				}
			}

			/**
			 * Temporarily applies a class to an element. The class is removed after the specified amount of time passes.
			 * @param {HTMLElement} e An element to style.
			 * @param {string} className A class name to apply temporarily.
			 * @param {number} time A time period the class should be removed after.
			 */
			function tmpStyle(e, className, time) {
				e.classList.add(className);
				setTimeout(() => {
					e.classList.remove(className);
				}, time);
			}

			function copiedFloater(x, y) {
				let fltr = document.createElement('div');
				fltr.classList.add('floater');
				fltr.style.left = (x - 45) + 'px';
				fltr.style.top = (y - 35) + 'px';
				fltr.innerHTML = 'Copied.';
				document.body.appendChild(fltr);

				setTimeout(() => {
					fltr.classList.add('vanishing');
				}, 0);

				setTimeout(() => {
					document.body.removeChild(fltr);
				}, 1000);
			}

			function tagMatch(el, terms) {
				return terms.reduce((res, term) => {
					return res && el.dataset.tag.includes(term);
				}, true);
			}

			document.body.onload = () => {
				//	The home screen filtering.
				let filter = document.getElementById('filter');
				let toolLinks = document.querySelectorAll('.tool-preview');
				filter.oninput = () => {
					if (filter.value) {
						let filterTerms = filter.value.split(/\s+/gi);
						toolLinks.forEach((tlE) => {
							if (tagMatch(tlE, filterTerms)) {
								tlE.classList.add('matched');
								tlE.classList.remove('filteredOut');
							} else {
								tlE.classList.remove('matched');
								tlE.classList.add('filteredOut');
							}
						})
					} else {
						toolLinks.forEach((tlE) => {
							tlE.classList.remove('matched');
							tlE.classList.remove('filteredOut');
						});
					}
				}
				
				filter.onkeydown = (e) => {
					if (e.key == 'Enter') {
						//	Focusing the only matched tool.
						let matched = document.querySelectorAll('.matched');
						if (matched.length == 1) {
							bench.equip(matched[0].dataset.toolid);
							e.preventDefault();
							e.cancelBubble = true;
						}
					} else if (e.key == 'Escape') {
						//	Clearing the filtering.
						filter.value = '';
						filter.dispatchEvent(new Event('input'));
					}
				}

				//	Autofocusing tools upon page load.
				//	The hash can contain a tool data after a '@'.
				if (window.location.hash) {
					let hashSegments = window.location.hash.substr(1).split('@');
					let data;

					if (hashSegments[1]) {
						data = JSON.parse(atob(hashSegments[1]));
					}

					bench.equip(hashSegments[0], data);
				}

				bench.render();
			}
		</script>
	</body>
</html>