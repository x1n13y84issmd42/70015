		</div>
		<!-- #toolshed, opened in toolshed.html -->

		<div id="uiStash"></div>

		<tool _id="unixtime" tag="unixtime" name="Unixtime">
			<block _id="ts">
				<overcontrols>
					<radio name="daname" _id="daidScuko" value="--">Scuko</radio>
					<radio name="daname" _id="daidBljad" value="--">Bljad</radio>
					<checkbox _id="checkie-norm" value="--">Checkie 1</checkbox>
					<checkbox _id="checkie-yeet" value="--">Checkie 2</checkbox>
				</overcontrols>
				<in type="text" autofocus label="Unixtime (also {args.theValue})"></in>
				<undercontrols error="true">
					<copy from="{Δ('ts')}"></copy>
					<reuse>
						<jsonyaml json="{Δ('ts')}">Convert it to YAML</jsonyaml>
						<base64 ascii="{Δ('ts')}">Base64-encode it</base64>
					</reuse>
				</undercontrols>

				<kvsection>Valyos</kvsection>
				<kvpair key="F00">B4RRR! (from $)</kvpair>
				<kvpair key="F00" value="B4RRR! (from value)"></kvpair>

				<kvsection>Moar</kvsection>
				<kvpair k="F00" v="B4RRR! (from v)"></kvpair>
				<kvpair k="F00" v="B4RRR! (from v) with {args.theValue}"></kvpair>
			</block>
		</tool>

		<script>
			let toolInst = document.querySelector('[_id=unixtime]')
			let toolComp = XUIC.tool(toolInst, {k: "A key", theValue: "T3H VALYOOO"});
			document.body.appendChild(toolComp);

			/**
			 * Temporarily applies a class to an element. The class is removed after the specified amount of time passes.
			 * @param {HTMLElement} e An element to style.
			 * @param {string} className A class name to apply temporarily.
			 * @param {number} time A time period the class should be removed after.
			 */
			function tmpStyle(e, className, time) {
				e.classList.add(className);
				setTimeout(() => {
					e.classList.remove(className);
				}, time);
			}

			function copiedFloater(x, y) {
				let fltr = document.createElement('div');
				fltr.classList.add("floater");
				fltr.style.left = (x - 45) + "px";
				fltr.style.top = (y - 35) + "px";
				fltr.innerHTML = 'Copied.';
				document.body.appendChild(fltr);

				setTimeout(() => {
					fltr.classList.add("vanishing");
				}, 0);

				setTimeout(() => {
					document.body.removeChild(fltr);
				}, 1000);
			}

			function onclickCopyToClipboard(e) {
				let from = e.currentTarget;

				//	Looking for a disabled parent.
				let pn = from.parentNode;
				while (pn) {
					if (pn.classList && pn.classList.contains('disabled')) {
						return;
					}
					pn = pn.parentNode;
				}

				if (from.dataset.value) {
					Clipboard.copy(from.dataset.value);
					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
					return;
				}
				
				if (from.dataset.from) {
					from = document.getElementById(from.dataset.from);
				}
				
				if (from) {	
					switch (from.tagName) {
						case "INPUT":
						case "TEXTAREA":
							Clipboard.copy(from.value);
							break;
							
						default:
							Clipboard.copy(from.innerHTML);
							break;
					}

					tmpStyle(from, 'copied', 200);
					copiedFloater(e.pageX, e.pageY);
				}
			}

			document.body.onload = () => {
				// let dialogE = Component.New('share', {
				// 	title: 'Share',
				// 	value: `${window.location.pathname}#yolo2020`
				// });
				// document.body.appendChild(dialogE);

				let filter = document.getElementById("filter");
				filter.oninput = () => {
					bench.filter(filter.value);
				}
				
				filter.onkeydown = (e) => {
					if (e.key == 'Enter') {
						//	Focusing the only matched tool.
						let matched = document.querySelectorAll(".matched");
						if (matched.length == 1) {
							focus(matched[0].id);
							e.preventDefault();
							e.cancelBubble = true;
						}
					} else if (e.key == 'Escape') {
						//	Clearing the filtering.
						filter.value = "";
						bench.filter("");
					}
				}

				//	Copy buttons.
				document.querySelectorAll('.copy').forEach((v, k, p) => {v.onclick = onclickCopyToClipboard});

				//	Autofocusing tools upon page load.
				if (window.location.hash) {
					bench.focus(window.location.hash.substr(1));
				}

				bench.render();
			}
		</script>
	</body>
</html>